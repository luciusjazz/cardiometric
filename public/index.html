<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CardioMetric v1.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1"></script>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0f172a">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f9fa;
        }

        .btn-record-active {
            background-color: #dc3545 !important;
            color: white !important;
        }

        .btn-record-active:hover {
            background-color: #c82333 !important;
        }

        .btn-freeze-active {
            background-color: #ffc107 !important;
            color: #212529 !important;
        }

        .btn-freeze-active:hover {
            background-color: #e0a800 !important;
        }

        .chart-container {
            position: relative;
            height: 50vh;
            width: 100%;
        }

        .hr-overlay {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 0.5rem 0.75rem;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            z-index: 10;
        }

        .hr-overlay .title {
            font-size: 0.75rem;
            color: #6b7280;
            font-weight: 600;
        }

        .hr-overlay .current {
            font-size: 1.25rem;
            font-weight: 700;
            color: #111827;
        }

        .hr-overlay .stats {
            font-size: 0.75rem;
            color: #374151;
            display: flex;
            gap: 0.5rem;
        }

        .fullscreen-review {
            position: fixed;
            inset: 0;
            background: #ffffff;
            z-index: 50;
            overflow: auto;
            padding: 1rem;
        }

        .fullscreen-review .review-chart-container {
            height: 60vh;
        }

        .review-chart-container canvas {
            touch-action: none;
        }

        .review-chart-container {
            position: relative;
            height: 25vh;
            width: 100%;
            cursor: grab;
        }

        .review-chart-container:active {
            cursor: grabbing;
        }

        .zoom-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 9999px;
            font-weight: bold;
            font-size: 1.25rem;
            line-height: 1;
            transition: background-color 0.2s;
        }

        input[type="number"] {
            -moz-appearance: textfield;
        }

        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type=range] {
            -webkit-appearance: none;
            margin: 10px 0;
            width: 100%;
            background: transparent;
        }

        input[type=range]:focus {
            outline: none;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8.4px;
            cursor: pointer;
            background: #d1d5db;
            border-radius: 1.3px;
        }

        input[type=range]::-webkit-slider-thumb {
            border: 1px solid #3b82f6;
            height: 24px;
            width: 12px;
            border-radius: 3px;
            background: #ffffff;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -8px;
        }
    </style>
</head>

<body class="flex flex-col min-h-screen">
    <header class="bg-white shadow-md">
        <div class="container mx-auto px-6 py-4">
            <h1 class="text-2xl font-bold text-gray-800">CardioMetric <span class="text-green-600">v1.0</span></h1>
        </div>
    </header>
    <main class="flex-grow container mx-auto p-4 md:p-6">
        <div class="bg-white rounded-lg shadow-lg p-4 md:p-6">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-4 mb-4 border-b pb-4">
                <div class="flex items-center gap-2">
                    <label for="participantId" class="font-semibold text-gray-700">ID do Participante:</label>
                    <input type="text" id="participantId" class="w-full border-gray-300 rounded-md shadow-sm"
                        placeholder="Ex: 001">
                </div>
                <!-- Campo Condi√ß√£o removido - usu√°rios usam marcadores para separar fases -->
                <div class="flex items-center gap-4 flex-wrap">
                    <div id="status-display"
                        class="flex items-center justify-center px-4 py-2 rounded-full bg-gray-200 text-gray-700 font-semibold">
                        <span class="h-3 w-3 rounded-full bg-red-500 mr-3"></span> Desconectado
                    </div>
                    <div id="hr-display"
                        class="hidden items-center justify-center px-4 py-2 rounded-full bg-pink-100 text-pink-800 font-semibold">
                        ‚ù§Ô∏è FC: <span id="hr-value" class="ml-2 font-bold">--</span> bpm
                    </div>
                    <div id="timer-display"
                        class="hidden items-center justify-center px-4 py-2 rounded-full bg-indigo-100 text-indigo-800 font-semibold">
                        ‚è±Ô∏è Tempo: <span id="timer-value" class="ml-2 font-bold">00:00</span>
                    </div>
                    <div id="battery-display"
                        class="hidden items-center justify-center px-3 py-2 rounded-full bg-gray-100 text-gray-700 font-semibold text-sm">
                        üîã <span id="battery-value">--</span>%
                    </div>
                </div>
            </div>
            <div class="flex flex-col md:flex-row items-center justify-between mb-4 gap-3">
                <div id="marker-section" class="hidden w-full md:w-auto flex items-center gap-2">
                    <input type="text" id="markerInput" class="border-gray-300 rounded-md shadow-sm"
                        placeholder="Descri√ß√£o do marcador...">
                    <button id="addMarkerButton"
                        class="bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600">Adicionar
                        Marcador</button>
                </div>
                <div class="w-full md:w-auto flex flex-col sm:flex-row gap-3">
                    <button id="connectButton"
                        class="w-full sm:w-auto bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 transition-colors shadow-sm">Conectar
                        ao Polar H10</button>
                    <button id="recordButton"
                        class="w-full sm:w-auto bg-gray-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-700 transition-colors shadow-sm"
                        disabled>Iniciar Grava√ß√£o</button>
                    <button id="exportSessionButton"
                        class="w-full sm:w-auto bg-emerald-700 text-white font-bold py-2 px-6 rounded-lg hover:bg-emerald-800 transition-colors shadow-sm"
                        disabled>Exportar Sess√£o (Arquivo)</button>
                    <button id="importSessionButton"
                        class="w-full sm:w-auto bg-slate-700 text-white font-bold py-2 px-6 rounded-lg hover:bg-slate-800 transition-colors shadow-sm">Importar
                        Sess√£o (Arquivo)</button>
                </div>
            </div>
            <div id="error-message"
                class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-md relative mb-4"
                role="alert">
                <strong class="font-bold">Erro: </strong>
                <span id="error-text" class="block sm:inline"></span>
            </div>
            <div class="border-t border-b py-4 mb-4">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-center">
                    <div class="font-semibold text-gray-700">Controlo de Filtros:</div>
                    <div class="flex flex-wrap gap-x-4 gap-y-2">
                        <label class="inline-flex items-center"><input type="radio" name="filterType" value="none"
                                class="form-radio" checked> <span class="ml-2">Nenhum</span></label>
                        <label class="inline-flex items-center"><input type="radio" name="filterType" value="lpf"
                                class="form-radio"> <span class="ml-2">Passa-Baixa</span></label>
                        <label class="inline-flex items-center"><input type="radio" name="filterType" value="hpf"
                                class="form-radio"> <span class="ml-2">Passa-Alta</span></label>
                        <label class="inline-flex items-center"><input type="radio" name="filterType" value="bandpass"
                                class="form-radio"> <span class="ml-2">Banda</span></label>
                    </div>
                    <div id="filter-inputs" class="flex items-center gap-4">
                        <label class="inline-flex items-center text-sm text-gray-600">
                            <input type="checkbox" id="liveFilterToggle" class="mr-2" checked>
                            Aplicar filtro em tempo real
                        </label>
                        <span id="filter-params" class="flex items-center gap-2"></span>
                    </div>
                </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
                <div id="metrics-panel" class="hidden md:col-span-1 bg-gray-50 p-4 rounded-lg border">
                    <h3 class="font-bold text-lg mb-3 text-gray-700">M√©tricas da Sess√£o</h3>
                    <div class="grid grid-cols-2 gap-4 text-gray-600">
                        <div>
                            <div class="text-sm font-semibold">FC Atual</div>
                            <div id="cur-hr-value" class="text-2xl font-bold text-pink-700">--</div>
                        </div>
                        <div>
                            <div class="text-sm font-semibold">FC M√©dia</div>
                            <div id="avg-hr-value" class="text-2xl font-bold text-gray-800">--</div>
                        </div>
                        <div>
                            <div class="text-sm font-semibold">FC de Pico</div>
                            <div id="peak-hr-value" class="text-2xl font-bold text-red-600">--</div>
                        </div>
                        <div>
                            <div class="text-sm font-semibold">FC M√≠nima</div>
                            <div id="min-hr-value" class="text-2xl font-bold text-blue-600">--</div>
                        </div>
                        <div>
                            <div class="text-sm font-semibold">Tempo de Grava√ß√£o</div>
                            <div id="metrics-timer" class="text-2xl font-bold text-indigo-700">00:00</div>
                        </div>
                    </div>
                </div>
                <div class="md:col-span-3">
                    <div class="chart-container">
                        <div id="hrOverlay" class="hr-overlay hidden">
                            <div class="title">Frequ√™ncia Card√≠aca</div>
                            <div class="current"><span id="hr-overlay-current">--</span> bpm</div>
                            <div class="stats">
                                <div>Min: <span id="hr-overlay-min">--</span></div>
                                <div>M√©d: <span id="hr-overlay-avg">--</span></div>
                                <div>Pico: <span id="hr-overlay-peak">--</span></div>
                            </div>
                        </div>
                        <canvas id="ecgChart"></canvas>
                    </div>
                    <div id="scroll-container" class="hidden mt-2">
                        <input type="range" id="scroll-bar" class="w-full" value="0" min="0" max="0">
                    </div>
                </div>
            </div>
            <div class="border-t pt-4 flex flex-col md:flex-row items-center justify-between gap-4">
                <div class="flex items-center gap-2">
                    <button id="freezeButton"
                        class="bg-yellow-400 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-yellow-500 shadow-sm"
                        disabled>Congelar Ecr√£</button>
                </div>
                <div class="flex items-center gap-3"><span class="font-semibold text-gray-700">Velocidade:</span><button
                        id="timeZoomOut" class="zoom-btn bg-gray-200 text-gray-700 hover:bg-gray-300">-</button><span
                        id="timeZoomLabel" class="w-20 text-center font-mono">25 mm/s</span><button id="timeZoomIn"
                        class="zoom-btn bg-gray-200 text-gray-700 hover:bg-gray-300">+</button></div>
                <div class="flex items-center gap-3"><span class="font-semibold text-gray-700">Amplitude
                        (¬µV):</span><button id="voltageZoomOut"
                        class="zoom-btn bg-gray-200 text-gray-700 hover:bg-gray-300">-</button><span
                        id="voltageZoomLabel" class="w-20 text-center font-mono">2000</span><button id="voltageZoomIn"
                        class="zoom-btn bg-gray-200 text-gray-700 hover:bg-gray-300">+</button></div>
                <div class="flex items-center gap-3">
                    <label class="inline-flex items-center text-sm text-gray-700">
                        <input type="checkbox" id="hrOverlayToggle" class="mr-2">
                        Mostrar FC sobreposta
                    </label>
                </div>
            </div>
        </div>
        <div id="review-section" class="hidden mt-6 bg-white rounded-lg shadow-lg p-4 md:p-6">
            <h2 class="text-xl font-bold text-gray-800 mb-4">Revis√£o e Exporta√ß√£o</h2>
            <div class="review-chart-container mb-2 bg-gray-50 rounded"><canvas id="reviewChart"></canvas></div>
            <div class="review-chart-container mb-2 bg-gray-50 rounded" style="height: 20vh;"><canvas
                    id="hrTrendChart"></canvas></div>
            <div id="markersList" class="mb-4 text-sm text-gray-700"></div>
            <!-- Controles de navega√ß√£o no topo para f√°cil acesso em mobile -->
            <div id="review-nav" class="flex flex-col gap-3 mb-4 sticky top-0 bg-white z-10 py-2">
                <div class="flex items-center justify-between gap-2 flex-wrap">
                    <div class="flex items-center gap-1">
                        <button id="reviewZoomOut"
                            class="bg-blue-500 text-white px-3 py-2 rounded hover:bg-blue-600 font-bold text-lg"
                            title="Zoom Out">‚àí</button>
                        <button id="reviewZoomIn"
                            class="bg-blue-500 text-white px-3 py-2 rounded hover:bg-blue-600 font-bold text-lg"
                            title="Zoom In">+</button>
                    </div>
                    <div class="flex items-center gap-1">
                        <button id="reviewPanFarLeft"
                            class="bg-gray-200 text-gray-700 px-3 py-2 rounded hover:bg-gray-300">¬´</button>
                        <button id="reviewPanLeft"
                            class="bg-gray-200 text-gray-700 px-3 py-2 rounded hover:bg-gray-300">‚Äπ</button>
                        <button id="reviewReset"
                            class="bg-gray-200 text-gray-700 px-3 py-2 rounded hover:bg-gray-300">Reset</button>
                        <button id="reviewPanRight"
                            class="bg-gray-200 text-gray-700 px-3 py-2 rounded hover:bg-gray-300">‚Ä∫</button>
                        <button id="reviewPanFarRight"
                            class="bg-gray-200 text-gray-700 px-3 py-2 rounded hover:bg-gray-300">¬ª</button>
                    </div>
                    <div class="flex items-center gap-3">
                        <div id="review-window-label" class="text-sm text-gray-600 font-mono">0.00‚Äì0.00 s</div>
                        <label class="inline-flex items-center text-sm text-gray-700">
                            <input type="checkbox" id="reviewFullscreenToggle" class="mr-2">
                            Expandir
                        </label>
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <input type="range" id="review-scroll-bar" class="w-full h-6" value="0" min="0" max="0"
                        style="touch-action: manipulation;">
                </div>
            </div>
            <div class="border-t border-b py-4 mb-4">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-center">
                    <div class="font-semibold text-gray-700">Filtro de Revis√£o:</div>
                    <div class="flex flex-wrap gap-x-4 gap-y-2">
                        <label class="inline-flex items-center"><input type="radio" name="reviewFilterType" value="none"
                                class="form-radio" checked> <span class="ml-2">Nenhum</span></label>
                        <label class="inline-flex items-center"><input type="radio" name="reviewFilterType" value="lpf"
                                class="form-radio"> <span class="ml-2">Passa-Baixa</span></label>
                        <label class="inline-flex items-center"><input type="radio" name="reviewFilterType" value="hpf"
                                class="form-radio"> <span class="ml-2">Passa-Alta</span></label>
                        <label class="inline-flex items-center"><input type="radio" name="reviewFilterType"
                                value="bandpass" class="form-radio"> <span class="ml-2">Banda</span></label>
                    </div>
                    <div id="review-filter-inputs" class="flex items-center gap-2"></div>
                </div>
            </div>
            <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
                <label class="font-semibold">Exportar de: <input type="number" id="startTime"
                        class="w-24 border-gray-300 rounded-md shadow-sm" value="0"> s</label>
                <label class="font-semibold">at√©: <input type="number" id="endTime"
                        class="w-24 border-gray-300 rounded-md shadow-sm" value="10"> s</label>
                <div class="flex flex-col sm:flex-row gap-2">
                    <button id="downloadEcgCsvButton"
                        class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700">Exportar ECG
                        (CSV)</button>
                    <button id="downloadRrCsvButton"
                        class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700">Exportar RR
                        (CSV)</button>
                    <button id="downloadPdfButton"
                        class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700">Exportar
                        PDF</button>
                </div>
            </div>
        </div>
    </main>
    <footer class="bg-white mt-8 py-4">
        <div class="container mx-auto text-center text-sm text-gray-500">
            <p>&copy; 2025-2027 CardioMetric - Projeto de Valida√ß√£o.</p>
        </div>
    </footer>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const { jsPDF } = window.jspdf;
            if (window.ChartZoom) { Chart.register(window.ChartZoom); }

            const allElements = {
                statusDisplay: document.getElementById('status-display'), hrDisplay: document.getElementById('hr-display'), hrValue: document.getElementById('hr-value'),
                batteryDisplay: document.getElementById('battery-display'), batteryValue: document.getElementById('battery-value'),
                connectButton: document.getElementById('connectButton'), recordButton: document.getElementById('recordButton'),
                freezeButton: document.getElementById('freezeButton'),
                metricsPanel: document.getElementById('metrics-panel'), curHrValue: document.getElementById('cur-hr-value'), avgHrValue: document.getElementById('avg-hr-value'),
                peakHrValue: document.getElementById('peak-hr-value'), minHrValue: document.getElementById('min-hr-value'),
                timeZoomIn: document.getElementById('timeZoomIn'), timeZoomOut: document.getElementById('timeZoomOut'),
                timeZoomLabel: document.getElementById('timeZoomLabel'), voltageZoomIn: document.getElementById('voltageZoomIn'),
                voltageZoomOut: document.getElementById('voltageZoomOut'), voltageZoomLabel: document.getElementById('voltageZoomLabel'),
                errorMessage: document.getElementById('error-message'), errorText: document.getElementById('error-text'),
                filterInputsContainer: document.getElementById('filter-inputs'),
                reviewSection: document.getElementById('review-section'), downloadEcgCsvButton: document.getElementById('downloadEcgCsvButton'),
                downloadRrCsvButton: document.getElementById('downloadRrCsvButton'), downloadPdfButton: document.getElementById('downloadPdfButton'),
                startTimeInput: document.getElementById('startTime'), endTimeInput: document.getElementById('endTime'),
                liveChartCtx: document.getElementById('ecgChart').getContext('2d'), reviewChartCtx: document.getElementById('reviewChart').getContext('2d'),
                participantIdInput: document.getElementById('participantId'), conditionSelect: document.getElementById('conditionSelect'),
                markerSection: document.getElementById('marker-section'), markerInput: document.getElementById('markerInput'),
                addMarkerButton: document.getElementById('addMarkerButton'),
                timerDisplay: document.getElementById('timer-display'), timerValue: document.getElementById('timer-value'),
                scrollContainer: document.getElementById('scroll-container'), scrollBar: document.getElementById('scroll-bar'),
                reviewFilterInputsContainer: document.getElementById('review-filter-inputs'),
                reviewScrollBar: document.getElementById('review-scroll-bar'),
                reviewWindowLabel: document.getElementById('review-window-label'),
                reviewPanLeft: document.getElementById('reviewPanLeft'), reviewPanRight: document.getElementById('reviewPanRight'),
                reviewPanFarLeft: document.getElementById('reviewPanFarLeft'), reviewPanFarRight: document.getElementById('reviewPanFarRight'),
                reviewReset: document.getElementById('reviewReset'),
                reviewFullscreenToggle: document.getElementById('reviewFullscreenToggle'),
                markersList: document.getElementById('markersList'),
                hrOverlay: document.getElementById('hrOverlay'),
                hrOverlayToggle: document.getElementById('hrOverlayToggle'),
                hrOverlayCurrent: document.getElementById('hr-overlay-current'),
                hrOverlayMin: document.getElementById('hr-overlay-min'),
                hrOverlayAvg: document.getElementById('hr-overlay-avg'),
                hrOverlayPeak: document.getElementById('hr-overlay-peak'),
                hrTrendChartCanvas: document.getElementById('hrTrendChart'),
            };

            let ecgChart, reviewChart, hrTrendChart, timerInterval, recordedData = [], recordedMarkers = [], liveBuffer = [], frozenBuffer = [], frozenSource = [], isRecording = false, isConnected = false, isFrozen = false, polarDevice, startTime, signalProcessor;
            let recordingStartTime = null; // Tempo de in√≠cio da grava√ß√£o (reset ao iniciar)
            let wakeLock = null; // Wake Lock para manter tela ligada durante grava√ß√£o
            let hasUnsavedData = false; // Controla se h√° dados n√£o salvos
            let autoSaveInterval = null; // Intervalo de auto-save
            let currentLiveFilterType = 'none';
            let lastHr = null, lastRr = [];
            let hrSamples = [], avgHr = 0, peakHr = 0, minHr = 300;
            let enableLiveFilter = true;

            // Aviso ao tentar sair da p√°gina com dados n√£o salvos
            window.addEventListener('beforeunload', (e) => {
                if (hasUnsavedData || isRecording || recordedData.length > 0) {
                    e.preventDefault();
                    e.returnValue = 'Voc√™ tem dados de grava√ß√£o n√£o salvos. Deseja realmente sair?';
                    return e.returnValue;
                }
            });

            // Auto-save no IndexedDB a cada 30 segundos durante grava√ß√£o
            function startAutoSave() {
                if (autoSaveInterval) return;
                autoSaveInterval = setInterval(async () => {
                    if (recordedData.length > 0) {
                        try {
                            const db = await openDB();
                            const payload = {
                                name: '__autosave__',
                                createdAt: new Date().toISOString(),
                                participant: allElements.participantIdInput.value,
                                condition: allElements.conditionSelect?.value || 'Coleta',
                                sampleRate: SAMPLE_RATE_HZ,
                                data: recordedData,
                                markers: recordedMarkers
                            };
                            await new Promise((resolve, reject) => {
                                const tx = db.transaction('sessions', 'readwrite');
                                tx.objectStore('sessions').put(payload);
                                tx.oncomplete = resolve;
                                tx.onerror = reject;
                            });
                            console.log('Auto-save realizado:', recordedData.length, 'pontos');
                        } catch (err) {
                            console.warn('Auto-save falhou:', err);
                        }
                    }
                }, 30000); // 30 segundos
            }
            function stopAutoSave() {
                if (autoSaveInterval) {
                    clearInterval(autoSaveInterval);
                    autoSaveInterval = null;
                }
            }

            const HEART_RATE_SERVICE_UUID = "heart_rate";
            const HEART_RATE_CHARACTERISTIC_UUID = "heart_rate_measurement";
            const BATTERY_SERVICE_UUID = "battery_service"; // 0x180F
            const BATTERY_LEVEL_CHARACTERISTIC_UUID = "battery_level"; // 0x2A19
            const POLAR_PMD_SERVICE_UUID = "fb005c80-02e7-f387-1cad-8acd2d8df0c8";
            const POLAR_PMD_CONTROL_UUID = "fb005c81-02e7-f387-1cad-8acd2d8df0c8";
            const POLAR_PMD_DATA_UUID = "fb005c82-02e7-f387-1cad-8acd2d8df0c8";
            const SAMPLE_RATE_HZ = 130;

            const timeConfigs = [{ label: '50 mm/s', points: SAMPLE_RATE_HZ * 2.5 }, { label: '25 mm/s', points: SAMPLE_RATE_HZ * 5 }, { label: '10 mm/s', points: SAMPLE_RATE_HZ * 12.5 }];
            let currentTimeZoomIndex = 1;
            const voltageConfigs = [{ label: '4000', min: -2000, max: 2000 }, { label: '2000', min: -1000, max: 1000 }, { label: '1000', min: -500, max: 500 }];
            let currentVoltageZoomIndex = 1;
            let MAX_DATA_POINTS = timeConfigs[currentTimeZoomIndex].points;

            class SignalProcessor {
                constructor(sampleRate) { this.sampleRate = sampleRate; this.lpfBuffer = []; this.LPF_WINDOW_SIZE = 5; this.hpfPrevInput = 0; this.hpfPrevOutput = 0; this.lpfCutoff = 40.0; this.hpfCutoff = 0.5; this.updateCoefficients(); }
                updateCoefficients() { const dt = 1.0 / this.sampleRate; const hpfRC = 1.0 / (2.0 * Math.PI * this.hpfCutoff); this.alphaHPF = hpfRC / (hpfRC + dt); }
                setHpfCutoff(freq) { this.hpfCutoff = freq; this.updateCoefficients(); }
                setLpfCutoff(freq) { /* For more advanced filters */ }
                process(sample, filterType) { if (filterType === 'none') return sample; if (filterType === 'lpf') return this.lowPassFilter(sample); if (filterType === 'hpf') return this.highPassFilter(sample); if (filterType === 'bandpass') { const lpfSample = this.lowPassFilter(sample); return this.highPassFilter(lpfSample); } return sample; }
                lowPassFilter(sample) { this.lpfBuffer.push(sample); if (this.lpfBuffer.length > this.LPF_WINDOW_SIZE) this.lpfBuffer.shift(); return this.lpfBuffer.reduce((a, b) => a + b, 0) / this.lpfBuffer.length; }
                highPassFilter(sample) { const hpfOutput = this.alphaHPF * (this.hpfPrevOutput + sample - this.hpfPrevInput); this.hpfPrevInput = sample; this.hpfPrevOutput = hpfOutput; return hpfOutput; }
                reset() { this.lpfBuffer = []; this.hpfPrevInput = 0; this.hpfPrevOutput = 0; }
            }

            function initChart() {
                const initialVoltage = voltageConfigs[currentVoltageZoomIndex];
                allElements.voltageZoomLabel.textContent = initialVoltage.label;
                ecgChart = new Chart(allElements.liveChartCtx, {
                    type: 'line', data: { labels: [], datasets: [{ label: 'ECG (¬µV)', data: [], borderColor: 'rgb(59, 130, 246)', borderWidth: 1.5, pointRadius: 0 }] },
                    options: { responsive: true, maintainAspectRatio: false, animation: false, scales: { x: { display: true, title: { display: true, text: 'Tempo (segundos)' }, ticks: { callback: function (value) { const labels = this.chart?.data?.labels || []; const lbl = labels[Math.round(value)] ?? value; const n = Number(lbl); return Number.isFinite(n) ? Math.round(n) : lbl; } } }, y: { min: initialVoltage.min, max: initialVoltage.max, title: { display: true, text: 'Amplitude (¬µV)' } } }, plugins: { legend: { display: false }, tooltip: { enabled: true } } }
                });
            }

            async function connectToPolar() {
                hideError();
                try {
                    allElements.statusDisplay.innerHTML = `<span class="h-3 w-3 rounded-full bg-yellow-500 mr-3 animate-ping"></span> Procurando...`;
                    polarDevice = await navigator.bluetooth.requestDevice({ filters: [{ namePrefix: 'Polar' }], optionalServices: [HEART_RATE_SERVICE_UUID, POLAR_PMD_SERVICE_UUID, BATTERY_SERVICE_UUID] });
                    allElements.statusDisplay.innerHTML = `<span class="h-3 w-3 rounded-full bg-yellow-500 mr-3 animate-ping"></span> Conectando a ${polarDevice.name}...`;
                    const server = await polarDevice.gatt.connect();
                    polarDevice.addEventListener('gattserverdisconnected', () => updateConnectionStatus(false));
                    signalProcessor = new SignalProcessor(SAMPLE_RATE_HZ);
                    // Ler bateria
                    try {
                        const batteryService = await server.getPrimaryService(BATTERY_SERVICE_UUID);
                        const batteryCharacteristic = await batteryService.getCharacteristic(BATTERY_LEVEL_CHARACTERISTIC_UUID);
                        const batteryValue = await batteryCharacteristic.readValue();
                        const batteryLevel = batteryValue.getUint8(0);
                        updateBatteryDisplay(batteryLevel);
                        // Atualizar bateria a cada 60 segundos
                        setInterval(async () => {
                            try {
                                if (polarDevice && polarDevice.gatt.connected) {
                                    const val = await batteryCharacteristic.readValue();
                                    updateBatteryDisplay(val.getUint8(0));
                                }
                            } catch (e) { console.warn('Erro ao atualizar bateria:', e); }
                        }, 60000);
                    } catch (battError) { console.warn("Servi√ßo de bateria n√£o encontrado.", battError); }
                    try {
                        const hrService = await server.getPrimaryService(HEART_RATE_SERVICE_UUID);
                        const hrCharacteristic = await hrService.getCharacteristic(HEART_RATE_CHARACTERISTIC_UUID);
                        hrCharacteristic.addEventListener('characteristicvaluechanged', handleHRData);
                        await hrCharacteristic.startNotifications();
                    } catch (hrError) { console.warn("Servi√ßo de FC n√£o encontrado ou falhou.", hrError); }
                    const pmdService = await server.getPrimaryService(POLAR_PMD_SERVICE_UUID);
                    const controlCharacteristic = await pmdService.getCharacteristic(POLAR_PMD_CONTROL_UUID);
                    const dataCharacteristic = await pmdService.getCharacteristic(POLAR_PMD_DATA_UUID);
                    await dataCharacteristic.startNotifications();
                    dataCharacteristic.addEventListener('characteristicvaluechanged', handleECGData);
                    const startEcgCommand = new Uint8Array([0x02, 0x00, 0x00, 0x01, 0x82, 0x00, 0x01, 0x01, 0x0E, 0x00]);
                    await controlCharacteristic.writeValue(startEcgCommand);
                    startTime = Date.now();
                    updateConnectionStatus(true, polarDevice.name);
                } catch (error) {
                    console.error("Erro na conex√£o Bluetooth:", error);
                    showError("N√£o foi poss√≠vel conectar. Dicas: 1) Certifique-se que o Polar H10 n√£o est√° conectado a outro app. 2) Verifique se a permiss√£o de Bluetooth para o Chrome est√° ativa.");
                    updateConnectionStatus(false);
                }
            }

            function handleHRData(event) {
                const value = event.target.value;
                const flags = value.getUint8(0);
                const heartRate = value.getUint8(1);
                allElements.hrValue.textContent = heartRate;
                if (allElements.curHrValue) allElements.curHrValue.textContent = heartRate > 0 ? heartRate : '--';
                lastHr = heartRate;
                // Atualiza overlay em tempo real
                if (allElements.hrOverlay && !allElements.hrOverlay.classList.contains('hidden')) {
                    allElements.hrOverlayCurrent.textContent = heartRate > 0 ? heartRate : '--';
                    allElements.hrOverlayMin.textContent = (minHr === 300) ? '--' : minHr;
                    allElements.hrOverlayPeak.textContent = (peakHr === 0) ? '--' : peakHr;
                    allElements.hrOverlayAvg.textContent = (avgHr > 0) ? Math.round(avgHr) : '--';
                }
                if (isRecording && heartRate > 0) {
                    hrSamples.push(heartRate);
                    peakHr = Math.max(peakHr, heartRate);
                    minHr = Math.min(minHr, heartRate);
                    avgHr = hrSamples.reduce((a, b) => a + b, 0) / hrSamples.length;
                    allElements.peakHrValue.textContent = peakHr;
                    allElements.minHrValue.textContent = minHr;
                    allElements.avgHrValue.textContent = avgHr.toFixed(0);
                    if (allElements.hrOverlay && !allElements.hrOverlay.classList.contains('hidden')) {
                        allElements.hrOverlayMin.textContent = minHr;
                        allElements.hrOverlayPeak.textContent = peakHr;
                        allElements.hrOverlayAvg.textContent = Math.round(avgHr);
                    }
                }
                const rrIntervals = [];
                if (flags & 0x10) {
                    let offset = 2;
                    while (offset < value.byteLength) { rrIntervals.push(value.getUint16(offset, true) * (1000.0 / 1024.0)); offset += 2; }
                }
                lastRr = rrIntervals;
            }

            function handleECGData(event) {
                const value = event.target.value;
                const bytes = new Uint8Array(value.buffer);
                const sampleTimeIncrement = 1 / SAMPLE_RATE_HZ;
                // Tempo para visualiza√ß√£o ao vivo (desde conex√£o)
                let liveTime = (Date.now() - startTime) / 1000;
                // Tempo para grava√ß√£o (desde in√≠cio da grava√ß√£o, come√ßa em 0)
                let recordTime = recordingStartTime ? (Date.now() - recordingStartTime) / 1000 : 0;
                let offset = 10;
                let currentRrIndex = 0;
                while (offset + 2 < bytes.length) {
                    let sample = (bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16));
                    if (sample & 0x800000) sample -= 0x1000000;
                    const rrValue = (lastRr && currentRrIndex < lastRr.length) ? lastRr[currentRrIndex] : '';
                    // Dados ao vivo usam tempo desde conex√£o
                    const liveDataPoint = { time: liveTime, signal: sample, hr: lastHr, rr: rrValue, marker: '' };
                    liveBuffer.push(liveDataPoint);
                    // Dados gravados usam tempo desde in√≠cio da grava√ß√£o (come√ßa em 0)
                    if (isRecording) {
                        const recordDataPoint = { time: recordTime, signal: sample, hr: lastHr, rr: rrValue, marker: '' };
                        recordedData.push(recordDataPoint);
                    }
                    if (rrValue !== '') currentRrIndex++;
                    liveTime += sampleTimeIncrement;
                    recordTime += sampleTimeIncrement;
                    offset += 3;
                }
                lastRr = [];
                if (!isFrozen) updateChartWithLiveData();
            }

            function updateChartWithLiveData() {
                if (!ecgChart) return;
                const activeFilter = document.querySelector('input[name="filterType"]:checked').value;
                if (activeFilter !== currentLiveFilterType && signalProcessor) {
                    signalProcessor.reset();
                    currentLiveFilterType = activeFilter;
                }
                while (liveBuffer.length > MAX_DATA_POINTS) liveBuffer.shift();
                ecgChart.data.labels = liveBuffer.map(d => Number(d.time).toFixed(2));
                ecgChart.data.datasets[0].data = liveBuffer.map(d => (enableLiveFilter && signalProcessor) ? signalProcessor.process(d.signal, activeFilter) : d.signal);
                updateLiveMarkersDataset();
                ecgChart.update('none');
            }

            function updateConnectionStatus(connected, deviceName = 'Polar H10') {
                isConnected = connected;
                allElements.freezeButton.disabled = !connected;
                allElements.reviewSection.classList.add('hidden');
                if (connected) {
                    allElements.statusDisplay.innerHTML = `<span class="h-3 w-3 rounded-full bg-green-500 mr-3 animate-pulse"></span> Conectado a ${deviceName}`;
                    allElements.statusDisplay.classList.replace('bg-gray-200', 'bg-green-100');
                    allElements.hrDisplay.classList.remove('hidden');
                    allElements.connectButton.textContent = 'Desconectar';
                    allElements.recordButton.disabled = false;
                } else {
                    allElements.statusDisplay.innerHTML = `<span class="h-3 w-3 rounded-full bg-red-500 mr-3"></span> Desconectado`;
                    allElements.statusDisplay.classList.replace('bg-green-100', 'bg-gray-200');
                    allElements.hrDisplay.classList.add('hidden');
                    allElements.connectButton.textContent = 'Conectar ao Polar H10';
                    allElements.recordButton.disabled = true;
                    allElements.recordButton.textContent = 'Iniciar Grava√ß√£o';
                    allElements.recordButton.classList.remove('btn-record-active');
                    allElements.metricsPanel.classList.add('hidden');
                    if (signalProcessor) signalProcessor.reset();
                    if (polarDevice && polarDevice.gatt.connected) { polarDevice.gatt.disconnect(); }
                }
            }

            function updateBatteryDisplay(level) {
                if (!allElements.batteryDisplay || !allElements.batteryValue) return;
                allElements.batteryValue.textContent = level;
                allElements.batteryDisplay.classList.remove('hidden');
                allElements.batteryDisplay.classList.add('flex');
                // Cores baseadas no n√≠vel de bateria
                allElements.batteryDisplay.classList.remove('bg-green-100', 'bg-yellow-100', 'bg-red-100', 'text-green-700', 'text-yellow-700', 'text-red-700');
                if (level > 50) {
                    allElements.batteryDisplay.classList.add('bg-green-100', 'text-green-700');
                } else if (level > 20) {
                    allElements.batteryDisplay.classList.add('bg-yellow-100', 'text-yellow-700');
                } else {
                    allElements.batteryDisplay.classList.add('bg-red-100', 'text-red-700');
                }
            }

            function startTimer() {
                let seconds = 0;
                allElements.timerValue.textContent = "00:00";
                allElements.timerDisplay.classList.remove('hidden');
                timerInterval = setInterval(() => {
                    seconds++;
                    const min = Math.floor(seconds / 60).toString().padStart(2, '0');
                    const sec = (seconds % 60).toString().padStart(2, '0');
                    allElements.timerValue.textContent = `${min}:${sec}`;
                    const mt = document.getElementById('metrics-timer');
                    if (mt) mt.textContent = `${min}:${sec}`;
                }, 1000);
            }

            function resetMetrics() { hrSamples = []; avgHr = 0; peakHr = 0; minHr = 300; allElements.avgHrValue.textContent = '--'; allElements.peakHrValue.textContent = '--'; allElements.minHrValue.textContent = '--'; }
            function showError(message) { allElements.errorText.textContent = message; allElements.errorMessage.classList.remove('hidden'); }
            function hideError() { allElements.errorMessage.classList.add('hidden'); }

            // Wake Lock: mant√©m tela ligada durante grava√ß√£o
            async function requestWakeLock() {
                if ('wakeLock' in navigator) {
                    try {
                        wakeLock = await navigator.wakeLock.request('screen');
                        console.log('‚úÖ Wake Lock ativado');
                        // Listener para quando o sistema liberar o wake lock
                        wakeLock.addEventListener('release', () => {
                            console.log('‚ö†Ô∏è Wake Lock foi liberado pelo sistema');
                            wakeLock = null;
                            // Tentar re-adquirir imediatamente se ainda estiver gravando
                            if (isRecording && document.visibilityState === 'visible') {
                                setTimeout(() => requestWakeLock(), 100);
                            }
                        });
                    } catch (err) {
                        console.warn('‚ùå Wake Lock falhou:', err.name, err.message);
                        // Fallback: tentar novamente ap√≥s 5 segundos
                        if (isRecording) {
                            setTimeout(() => requestWakeLock(), 5000);
                        }
                    }
                } else {
                    console.warn('Wake Lock API n√£o suportada neste navegador');
                }
            }
            async function releaseWakeLock() {
                if (wakeLock) {
                    try {
                        await wakeLock.release();
                        console.log('Wake Lock liberado manualmente');
                    } catch (e) { }
                    wakeLock = null;
                }
            }
            // Re-adquirir Wake Lock quando p√°gina voltar vis√≠vel
            document.addEventListener('visibilitychange', async () => {
                if (document.visibilityState === 'visible' && isRecording && !wakeLock) {
                    console.log('P√°gina vis√≠vel novamente, re-adquirindo Wake Lock...');
                    await requestWakeLock();
                }
            });

            allElements.connectButton.addEventListener('click', () => { isConnected ? updateConnectionStatus(false) : connectToPolar(); });

            allElements.recordButton.addEventListener('click', async () => {
                isRecording = !isRecording;
                allElements.recordButton.textContent = isRecording ? 'Parar Grava√ß√£o' : 'Iniciar Grava√ß√£o';
                allElements.recordButton.classList.toggle('btn-record-active', isRecording);
                allElements.reviewSection.classList.add('hidden');
                allElements.markerSection.classList.toggle('hidden', !isRecording);
                if (isRecording) {
                    recordedData = [];
                    recordedMarkers = [];
                    recordingStartTime = Date.now(); // RESET: tempo come√ßa do zero ao gravar
                    hasUnsavedData = true; // Marcar dados n√£o salvos
                    resetMetrics();
                    allElements.metricsPanel.classList.remove('hidden');
                    startTimer();
                    setSaveButtonsState();
                    await requestWakeLock(); // Manter tela ligada
                    startAutoSave(); // Iniciar auto-save
                } else {
                    stopAutoSave(); // Parar auto-save
                    await releaseWakeLock(); // Liberar Wake Lock
                    allElements.metricsPanel.classList.add('hidden');
                    allElements.timerDisplay.classList.add('hidden');
                    clearInterval(timerInterval);
                    if (recordedData.length > 0) displayReview();
                    setSaveButtonsState();
                }
            });

            function updateFrozenChart(scrollIndex) {
                const start = Math.max(0, scrollIndex);
                const end = start + MAX_DATA_POINTS;
                const dataSlice = frozenSource.slice(start, end);
                const activeFilter = document.querySelector('input[name="filterType"]:checked').value;
                const tempProcessor = new SignalProcessor(SAMPLE_RATE_HZ);
                ecgChart.data.labels = dataSlice.map(d => Number(d.time).toFixed(2));
                ecgChart.data.datasets[0].data = dataSlice.map(d => tempProcessor.process(d.signal, activeFilter));
                updateLiveMarkersDataset(true, start, end);
                ecgChart.update('none');
            }

            allElements.freezeButton.addEventListener('click', () => {
                isFrozen = !isFrozen;
                allElements.freezeButton.textContent = isFrozen ? 'Retomar' : 'Congelar Ecr√£';
                allElements.freezeButton.classList.toggle('btn-freeze-active', isFrozen);
                allElements.scrollContainer.classList.toggle('hidden', !isFrozen);
                if (isFrozen) {
                    frozenSource = recordedData.length > 0 ? recordedData : [...liveBuffer];
                    allElements.scrollBar.max = Math.max(0, frozenSource.length - MAX_DATA_POINTS);
                    allElements.scrollBar.value = allElements.scrollBar.max;
                    updateFrozenChart(parseInt(allElements.scrollBar.value));
                } else {
                    updateChartWithLiveData();
                }
            });

            allElements.scrollBar.addEventListener('input', (e) => {
                if (isFrozen) {
                    updateFrozenChart(parseInt(e.target.value));
                }
            });

            allElements.addMarkerButton.addEventListener('click', () => {
                if (!isRecording) return;
                // Tempo relativo ao in√≠cio da grava√ß√£o (n√£o da conex√£o)
                const time = recordingStartTime ? (Date.now() - recordingStartTime) / 1000 : 0;
                const label = allElements.markerInput.value || 'Marcador';
                recordedMarkers.push({ time: time, label: label });
                allElements.markerInput.value = '';
                updateLiveMarkersDataset();
            });

            // Extrai dados de FC √∫nicos para o gr√°fico de tend√™ncia
            function extractHrTrendData() {
                const hrPoints = [];
                let lastHr = null;
                for (const d of recordedData) {
                    if (d.hr && d.hr !== lastHr) {
                        hrPoints.push({ time: d.time, hr: d.hr });
                        lastHr = d.hr;
                    }
                }
                return hrPoints;
            }

            function displayReview() {
                allElements.reviewSection.classList.remove('hidden');
                if (reviewChart) reviewChart.destroy();
                const labels = recordedData.map(d => d.time);
                const data = recordedData.map(d => d.signal);
                const maxTime = Math.ceil(recordedData.length > 0 ? recordedData[recordedData.length - 1].time : 0);
                allElements.startTimeInput.value = 0;
                allElements.endTimeInput.value = maxTime;
                reviewChart = new Chart(allElements.reviewChartCtx, {
                    type: 'line',
                    data: {
                        labels: labels, datasets: [
                            { label: 'Registo Completo (¬µV)', data: data, borderColor: 'rgb(75, 192, 192)', borderWidth: 1, pointRadius: 0 }
                        ]
                    },
                    options: { responsive: true, maintainAspectRatio: false, animation: false, scales: { x: { title: { text: 'Tempo (s)' }, ticks: { autoSkip: true, maxTicksLimit: 8, callback: function (value) { const labels = this.chart?.data?.labels || []; const lbl = labels[Math.round(value)] ?? value; const n = Number(lbl); return Number.isFinite(n) ? Math.round(n) + 's' : lbl; } } } }, plugins: { annotation: { annotations: buildMarkerAnnotations(labels) }, zoom: { pan: { enabled: true, mode: 'x', threshold: 5, onPanComplete: () => { updateReviewNavFromChart(); } }, zoom: { wheel: { enabled: true, speed: 0.1 }, pinch: { enabled: true }, drag: { enabled: false }, mode: 'x', onZoomComplete: () => { updateReviewNavFromChart(); } } }, tooltip: { callbacks: { label: function (ctx) { const y = ctx.parsed.y; return `ECG: ${Math.round(y)} ¬µV @ ${Number(ctx.label).toFixed(2)} s`; } } } } }
                });
                // Atualiza filtros de revis√£o e aplica imediatamente
                updateReviewFilterInputs();
                updateReviewChartData();
                // Inicializa navega√ß√£o
                setTimeout(updateReviewNavFromChart, 0);
                renderMarkersList();
                // Criar gr√°fico de tend√™ncia de FC
                if (hrTrendChart) hrTrendChart.destroy();
                const hrData = extractHrTrendData();
                if (hrData.length > 0 && allElements.hrTrendChartCanvas) {
                    // Calcular escala Y din√¢mica baseada nos dados
                    const hrValues = hrData.map(d => d.hr);
                    const hrMin = Math.min(...hrValues);
                    const hrMax = Math.max(...hrValues);
                    const hrPadding = Math.max(5, (hrMax - hrMin) * 0.15);
                    const yMin = Math.max(30, hrMin - hrPadding);
                    const yMax = Math.min(220, hrMax + hrPadding);

                    hrTrendChart = new Chart(allElements.hrTrendChartCanvas.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: hrData.map(d => d.time.toFixed(2)),
                            datasets: [{
                                label: 'FC (bpm)',
                                data: hrData.map(d => d.hr),
                                borderColor: 'rgb(239, 68, 68)',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                fill: true,
                                tension: 0.3,
                                pointRadius: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            animation: false,
                            scales: {
                                x: {
                                    title: { display: true, text: 'Tempo (s)' },
                                    ticks: { autoSkip: true, maxTicksLimit: 10 }
                                },
                                y: {
                                    title: { display: true, text: 'FC (bpm)' },
                                    min: yMin,
                                    max: yMax
                                }
                            },
                            plugins: {
                                legend: { display: false },
                                zoom: {
                                    pan: { enabled: true, mode: 'x', onPanComplete: () => { syncHrChartFromEcg(); } },
                                    zoom: {
                                        wheel: { enabled: true },
                                        pinch: { enabled: true },
                                        drag: { enabled: true, modifierKey: null },
                                        mode: 'x',
                                        onZoomComplete: () => { syncHrChartFromEcg(); }
                                    }
                                }
                            }
                        }
                    });
                }
            }

            function updateReviewFilterInputs() {
                const selected = document.querySelector('input[name="reviewFilterType"]:checked')?.value || 'none';
                let html = '';
                if (selected === 'lpf') {
                    html = `<label class="text-sm">F.Corte(Hz): <input type="number" id="review-lpf-cutoff" class="w-20 border-gray-300 rounded-md shadow-sm" value="40"></label>`;
                } else if (selected === 'hpf') {
                    html = `<label class="text-sm">F.Corte(Hz): <input type="number" id="review-hpf-cutoff" class="w-20 border-gray-300 rounded-md shadow-sm" value="0.5"></label>`;
                } else if (selected === 'bandpass') {
                    html = `<label class="text-sm">Inf(Hz): <input type="number" id="review-hpf-cutoff" class="w-20 border-gray-300 rounded-md shadow-sm" value="0.5"></label>
                            <label class="text-sm">Sup(Hz): <input type="number" id="review-lpf-cutoff" class="w-20 border-gray-300 rounded-md shadow-sm" value="40"></label>`;
                }
                if (allElements.reviewFilterInputsContainer) allElements.reviewFilterInputsContainer.innerHTML = html;
                const lpfEl = document.getElementById('review-lpf-cutoff');
                const hpfEl = document.getElementById('review-hpf-cutoff');
                if (lpfEl) lpfEl.addEventListener('change', updateReviewChartData);
                if (hpfEl) hpfEl.addEventListener('change', updateReviewChartData);
            }

            function updateReviewChartData() {
                if (!reviewChart) return;
                const selected = document.querySelector('input[name="reviewFilterType"]:checked')?.value || 'none';
                const proc = new SignalProcessor(SAMPLE_RATE_HZ);
                const lpfVal = parseFloat(document.getElementById('review-lpf-cutoff')?.value);
                const hpfVal = parseFloat(document.getElementById('review-hpf-cutoff')?.value);
                if (!isNaN(lpfVal)) proc.setLpfCutoff(lpfVal);
                if (!isNaN(hpfVal)) proc.setHpfCutoff(hpfVal);
                const labels = recordedData.map(d => d.time);
                const data = recordedData.map(d => proc.process(d.signal, selected));
                reviewChart.data.labels = labels;
                reviewChart.data.datasets[0].data = data;
                // Atualizar annotations de marcadores
                reviewChart.options.plugins.annotation.annotations = buildMarkerAnnotations(labels);
                reviewChart.update('none');
                updateReviewNavFromChart();
                renderMarkersList();
            }

            // -------- Navega√ß√£o Revis√£o (scrollbar, pan/zoom bot√µes) --------
            function getReviewWindow() {
                const scale = reviewChart?.scales?.x;
                if (!scale) return { minIdx: 0, maxIdx: reviewChart.data.labels.length - 1 };
                // Para escala categ√≥rica, min/max s√£o √≠ndices
                const minIdx = Math.max(0, Math.floor(scale.min ?? 0));
                const maxIdx = Math.min(reviewChart.data.labels.length - 1, Math.ceil(scale.max ?? (reviewChart.data.labels.length - 1)));
                return { minIdx, maxIdx };
            }
            function setReviewWindow(startIdx, windowSize) {
                const total = reviewChart.data.labels.length;
                const w = Math.max(10, Math.min(windowSize, total));
                const s = Math.max(0, Math.min(startIdx, total - w));
                const e = s + w - 1;
                reviewChart.options.scales.x.min = s;
                reviewChart.options.scales.x.max = e;
                reviewChart.update('none');
                updateReviewNavFromChart();
            }
            function updateReviewNavFromChart() {
                if (!reviewChart) return;
                const { minIdx, maxIdx } = getReviewWindow();
                const labels = reviewChart.data.labels;
                const startT = Number(labels[minIdx]) ?? 0;
                const endT = Number(labels[maxIdx]) ?? 0;
                if (allElements.reviewWindowLabel) {
                    allElements.reviewWindowLabel.textContent = `${Math.round(startT)}‚Äì${Math.round(endT)} s`;
                }
                if (allElements.reviewScrollBar) {
                    const windowSize = (maxIdx - minIdx + 1);
                    const totalPoints = labels.length;
                    allElements.reviewScrollBar.max = Math.max(0, totalPoints - windowSize);
                    allElements.reviewScrollBar.value = String(minIdx);
                    allElements.reviewScrollBar.dataset.window = String(windowSize);
                    // Step din√¢mico para suavizar scroll (m√≠nimo 10% da janela ou 100 pontos)
                    const step = Math.max(1, Math.floor(windowSize * 0.1), Math.floor(totalPoints / 500));
                    allElements.reviewScrollBar.step = String(step);
                }
                // Sincronizar gr√°fico de FC
                syncHrChartFromEcg();
                // Atualizar lista de marcadores vis√≠veis
                renderMarkersList();
            }

            // Sincroniza o gr√°fico de FC com a janela do ECG
            function syncHrChartFromEcg() {
                if (!hrTrendChart || !reviewChart) return;
                const ecgLabels = reviewChart.data.labels;
                const hrLabels = hrTrendChart.data.labels;
                if (!ecgLabels.length || !hrLabels.length) return;

                // Obter janela de tempo do ECG
                const { minIdx, maxIdx } = getReviewWindow();
                const startTime = Number(ecgLabels[minIdx]);
                const endTime = Number(ecgLabels[maxIdx]);

                // Encontrar √≠ndices correspondentes no gr√°fico de FC
                let hrMinIdx = 0, hrMaxIdx = hrLabels.length - 1;
                for (let i = 0; i < hrLabels.length; i++) {
                    if (Number(hrLabels[i]) >= startTime) { hrMinIdx = i; break; }
                }
                for (let i = hrLabels.length - 1; i >= 0; i--) {
                    if (Number(hrLabels[i]) <= endTime) { hrMaxIdx = i; break; }
                }

                // Aplicar mesma janela ao gr√°fico de FC
                hrTrendChart.options.scales.x.min = hrMinIdx;
                hrTrendChart.options.scales.x.max = hrMaxIdx;
                hrTrendChart.update('none');
            }
            if (allElements.reviewScrollBar) {
                allElements.reviewScrollBar.addEventListener('input', (e) => {
                    const start = parseInt(e.target.value);
                    const windowSize = parseInt(e.target.dataset.window || '100');
                    setReviewWindow(start, windowSize);
                    renderMarkersList();
                });
            }
            function panReview(deltaFraction = 0.25) {
                const { minIdx, maxIdx } = getReviewWindow();
                const windowSize = (maxIdx - minIdx + 1);
                const delta = Math.max(1, Math.round(windowSize * deltaFraction));
                setReviewWindow(minIdx + delta, windowSize);
            }
            function panReviewLeft(deltaFraction = 0.25) {
                const { minIdx, maxIdx } = getReviewWindow();
                const windowSize = (maxIdx - minIdx + 1);
                const delta = Math.max(1, Math.round(windowSize * deltaFraction));
                setReviewWindow(minIdx - delta, windowSize);
            }
            function zoomReview(factor = 0.8) {
                const { minIdx, maxIdx } = getReviewWindow();
                const center = Math.round((minIdx + maxIdx) / 2);
                const windowSize = (maxIdx - minIdx + 1);
                const newSize = Math.max(10, Math.round(windowSize * factor));
                setReviewWindow(center - Math.floor(newSize / 2), newSize);
            }
            function resetReviewView() {
                reviewChart.resetZoom();
                updateReviewNavFromChart();
            }
            // Bot√µes
            allElements.reviewPanLeft?.addEventListener('click', () => panReviewLeft());
            allElements.reviewPanRight?.addEventListener('click', () => panReview());
            allElements.reviewPanFarLeft?.addEventListener('click', () => setReviewWindow(0, reviewChart.data.labels.length));
            allElements.reviewPanFarRight?.addEventListener('click', () => setReviewWindow(reviewChart.data.labels.length - (getReviewWindow().maxIdx - getReviewWindow().minIdx + 1), (getReviewWindow().maxIdx - getReviewWindow().minIdx + 1)));
            allElements.reviewReset?.addEventListener('click', resetReviewView);
            // Bot√µes de zoom
            document.getElementById('reviewZoomIn')?.addEventListener('click', () => zoomReview(0.6)); // Zoom in mais agressivo
            document.getElementById('reviewZoomOut')?.addEventListener('click', () => zoomReview(1.6)); // Zoom out mais agressivo

            // Teclas de atalho: ‚Üê/‚Üí pan, +/- zoom
            window.addEventListener('keydown', (e) => {
                if (!allElements.reviewSection || allElements.reviewSection.classList.contains('hidden')) return;
                if (e.key === 'ArrowLeft') { e.preventDefault(); panReviewLeft(); }
                else if (e.key === 'ArrowRight') { e.preventDefault(); panReview(); }
                else if (e.key === '+') { e.preventDefault(); zoomReview(0.8); }
                else if (e.key === '=') { e.preventDefault(); zoomReview(0.8); }
                else if (e.key === '-') { e.preventDefault(); zoomReview(1.25); }
                else if (e.key.toLowerCase() === 'r') { e.preventDefault(); resetReviewView(); }
            });

            // Expandir revis√£o (fullscreen-like)
            if (allElements.reviewFullscreenToggle) {
                allElements.reviewFullscreenToggle.addEventListener('change', (e) => {
                    const enabled = e.target.checked;
                    if (enabled) {
                        allElements.reviewSection.classList.add('fullscreen-review');
                    } else {
                        allElements.reviewSection.classList.remove('fullscreen-review');
                    }
                    setTimeout(() => { if (reviewChart) { reviewChart.resize(); updateReviewNavFromChart(); } }, 50);
                });
            }

            // ---- Marcadores: utilit√°rios ----
            function findNearestMarker(time) {
                if (!recordedMarkers || recordedMarkers.length === 0) return null;
                let best = null; let bestDelta = Infinity;
                recordedMarkers.forEach(m => { const d = Math.abs(m.time - time); if (d < bestDelta) { bestDelta = d; best = m; } });
                return best;
            }
            function renderMarkersList() {
                if (!allElements.markersList || !reviewChart) return;
                const { minIdx, maxIdx } = getReviewWindow();
                const labels = reviewChart.data.labels;
                const startT = Number(labels[minIdx]) ?? 0;
                const endT = Number(labels[maxIdx]) ?? 0;
                const visible = recordedMarkers.filter(m => m.time >= startT && m.time <= endT);
                if (visible.length === 0) { allElements.markersList.innerHTML = '<div class="text-gray-400">Sem marcadores nesta janela.</div>'; return; }
                const items = visible.map(m => `<button data-time="${m.time}" class="mr-2 mb-2 inline-block bg-gray-100 hover:bg-gray-200 text-gray-700 px-2 py-1 rounded">${m.time.toFixed(2)}s ‚Äî ${m.label}</button>`).join('');
                allElements.markersList.innerHTML = `<div class="mb-1 font-semibold text-gray-700">Marcadores nesta janela:</div><div>${items}</div>`;
                allElements.markersList.querySelectorAll('button[data-time]')?.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const t = parseFloat(btn.getAttribute('data-time'));
                        // centraliza a janela no marcador
                        const { minIdx, maxIdx } = getReviewWindow();
                        const windowSize = (maxIdx - minIdx + 1);
                        // encontra √≠ndice mais pr√≥ximo ao tempo
                        let bestIndex = 0; let bestDelta = Infinity;
                        for (let i = 0; i < labels.length; i++) {
                            const d = Math.abs(Number(labels[i]) - t);
                            if (d < bestDelta) { bestDelta = d; bestIndex = i; }
                        }
                        setReviewWindow(Math.max(0, bestIndex - Math.floor(windowSize / 2)), windowSize);
                    });
                });
            }

            function updateLiveMarkersDataset(isFrozenMode = false, startIdx = 0, endIdx = 0) {
                if (!ecgChart) return;
                const labels = ecgChart.data.labels;
                const yMax = ecgChart.options.scales.y.max;
                const markerData = new Array(labels.length).fill(null);
                recordedMarkers.forEach(m => {
                    let bestIndex = -1; let bestDelta = Infinity;
                    for (let i = 0; i < labels.length; i++) {
                        const t = labels[i];
                        const delta = Math.abs(t - m.time);
                        if (delta < bestDelta) { bestDelta = delta; bestIndex = i; }
                    }
                    if (bestIndex >= 0) markerData[bestIndex] = yMax;
                });
                if (!ecgChart.data.datasets[1]) {
                    ecgChart.data.datasets.push({ label: 'Marcadores', data: markerData, borderColor: 'rgba(255,0,0,0)', pointBackgroundColor: 'red', pointRadius: 4, showLine: false });
                } else {
                    ecgChart.data.datasets[1].data = markerData;
                }
            }

            function buildMarkersAligned(labels) {
                const out = new Array(labels.length).fill(null);
                recordedMarkers.forEach(m => {
                    let bestIndex = -1; let bestDelta = Infinity;
                    for (let i = 0; i < labels.length; i++) {
                        const delta = Math.abs(labels[i] - m.time);
                        if (delta < bestDelta) { bestDelta = delta; bestIndex = i; }
                    }
                    if (bestIndex >= 0) out[bestIndex] = 0; // posicao neutra; so para desenhar o ponto
                });
                return out;
            }

            // Gera annotations de linhas verticais para marcadores
            function buildMarkerAnnotations(labels) {
                const annotations = {};
                recordedMarkers.forEach((m, idx) => {
                    // Encontrar √≠ndice mais pr√≥ximo
                    let bestIndex = -1; let bestDelta = Infinity;
                    for (let i = 0; i < labels.length; i++) {
                        const delta = Math.abs(labels[i] - m.time);
                        if (delta < bestDelta) { bestDelta = delta; bestIndex = i; }
                    }
                    if (bestIndex >= 0) {
                        annotations[`marker_${idx}`] = {
                            type: 'line',
                            xMin: bestIndex,
                            xMax: bestIndex,
                            borderColor: 'rgba(239, 68, 68, 0.8)',
                            borderWidth: 2,
                            borderDash: [5, 3],
                            label: {
                                display: true,
                                content: m.label || `M${idx + 1}`,
                                position: 'start',
                                backgroundColor: 'rgba(239, 68, 68, 0.9)',
                                color: 'white',
                                font: { size: 10 }
                            }
                        };
                    }
                });
                return annotations;
            }

            function getSelectedData() {
                const start = parseFloat(allElements.startTimeInput.value);
                const end = parseFloat(allElements.endTimeInput.value);
                return recordedData.filter(d => d.time >= start && d.time <= end);
            }

            function getFileName() {
                const pId = allElements.participantIdInput.value.replace(/ /g, "_") || 'UNKNOWN';
                const cond = allElements.conditionSelect?.value || 'Coleta';
                return `ecg_data_${pId}_${cond}_${new Date().toISOString().replace(/[:.]/g, '-')}`;
            }

            // ----- IndexedDB: salvar/carregar sess√µes -----
            const DB_NAME = 'ecg-app-db';
            const DB_VERSION = 1;
            let idb;
            function openDB() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(DB_NAME, DB_VERSION);
                    req.onupgradeneeded = () => {
                        const db = req.result;
                        if (!db.objectStoreNames.contains('sessions')) {
                            db.createObjectStore('sessions', { keyPath: 'name' });
                        }
                    };
                    req.onsuccess = () => { idb = req.result; resolve(idb); };
                    req.onerror = () => reject(req.error);
                });
            }
            function saveSession(name) {
                if (!name) return Promise.resolve(false);
                const payload = {
                    name,
                    createdAt: new Date().toISOString(),
                    participant: allElements.participantIdInput.value,
                    condition: allElements.conditionSelect?.value || 'Coleta',
                    sampleRate: SAMPLE_RATE_HZ,
                    data: recordedData,
                    markers: recordedMarkers
                };
                return openDB().then(db => new Promise((resolve, reject) => {
                    const tx = db.transaction('sessions', 'readwrite');
                    tx.objectStore('sessions').put(payload);
                    tx.oncomplete = () => resolve(true);
                    tx.onerror = () => reject(tx.error);
                }));
            }
            function loadSession(name) {
                return openDB().then(db => new Promise((resolve, reject) => {
                    const tx = db.transaction('sessions', 'readonly');
                    const req = tx.objectStore('sessions').get(name);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                }));
            }
            function setSaveButtonsState() {
                const disabled = recordedData.length === 0;
                const exp = document.getElementById('exportSessionButton');
                if (exp) exp.disabled = disabled;
            }
            // Removido fluxo por IndexedDB via bot√µes (mantemos apenas export/import por arquivo na UI)

            // Exportar/Importar sess√£o como arquivo (JSON)
            function serializeSession() {
                return JSON.stringify({
                    participant: allElements.participantIdInput.value,
                    condition: allElements.conditionSelect?.value || 'Coleta',
                    sampleRate: SAMPLE_RATE_HZ,
                    data: recordedData,
                    markers: recordedMarkers,
                    createdAt: new Date().toISOString()
                });
            }
            function triggerDownload(filename, text, mime = 'application/json') {
                const blob = new Blob([text], { type: mime });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            document.getElementById('exportSessionButton')?.addEventListener('click', () => {
                if (recordedData.length === 0) { alert('Nenhum dado para exportar.'); return; }
                const filename = `${getFileName()}_SESSION.json`;
                triggerDownload(filename, serializeSession());
                hasUnsavedData = false; // Dados foram salvos
                alert('Arquivo de sess√£o exportado. Guarde-o em local seguro.');
            });
            document.getElementById('exportSessionFromReviewButton')?.addEventListener('click', () => {
                if (recordedData.length === 0) { alert('Nenhum dado para exportar.'); return; }
                const filename = `${getFileName()}_SESSION.json`;
                triggerDownload(filename, serializeSession());
                hasUnsavedData = false; // Dados foram salvos
            });
            function readFileAsText(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }
            async function importSessionFromFile() {
                const input = document.createElement('input');
                input.type = 'file'; input.accept = '.json,application/json';
                input.onchange = async () => {
                    const file = input.files?.[0]; if (!file) return;
                    try {
                        const text = await readFileAsText(file);
                        const sess = JSON.parse(text);
                        recordedData = sess.data || [];
                        recordedMarkers = sess.markers || [];
                        allElements.participantIdInput.value = sess.participant || '';
                        // Campo condi√ß√£o foi removido
                        displayReview();
                        alert('Sess√£o importada do arquivo.');
                    } catch (e) {
                        alert('Falha ao importar arquivo.');
                    }
                };
                input.click();
            }
            document.getElementById('importSessionButton')?.addEventListener('click', importSessionFromFile);
            document.getElementById('importSessionFromReviewButton')?.addEventListener('click', importSessionFromFile);

            allElements.downloadEcgCsvButton.addEventListener('click', () => {
                const dataToExport = getSelectedData();
                if (dataToExport.length === 0) return;
                let csvContent = "data:text/csv;charset=utf-8,time_s;ecg_uv;marker\n";
                dataToExport.forEach(row => {
                    const marker = recordedMarkers.find(m => Math.abs(m.time - row.time) < (1 / SAMPLE_RATE_HZ));
                    const label = marker ? '"' + marker.label.replace(/"/g, '\\"') + '"' : '';
                    csvContent += `${String(row.time.toFixed(2)).replace('.', ',')};${row.signal.toFixed(0)};${label}\n`;
                });
                const link = document.createElement("a");
                link.setAttribute("href", encodeURI(csvContent));
                link.setAttribute("download", `${getFileName()}_ECG.csv`);
                document.body.appendChild(link); link.click(); document.body.removeChild(link);
            });

            allElements.downloadRrCsvButton.addEventListener('click', () => {
                let rrDataToExport = recordedData.filter(d => d.rr).map(d => ({ time: d.time, hr: d.hr, rr: d.rr }));
                if (rrDataToExport.length === 0) { alert("Nenhum dado de RR gravado."); return; }
                let csvContent = "data:text/csv;charset=utf-8,time_s;hr_bpm;rr_ms;marker\n";
                rrDataToExport.forEach(row => {
                    const marker = recordedMarkers.find(m => Math.abs(m.time - row.time) < 0.5);
                    csvContent += `${String(row.time).replace('.', ',')};${row.hr};${String(row.rr).replace('.', ',')};${marker ? '"' + marker.label.replace(/"/g, '\"') + '"' : ''}\n`;
                });
                const link = document.createElement("a");
                link.setAttribute("href", encodeURI(csvContent));
                link.setAttribute("download", `${getFileName()}_RR.csv`);
                document.body.appendChild(link); link.click(); document.body.removeChild(link);
            });

            allElements.downloadPdfButton.addEventListener('click', () => {
                const dataToExport = getSelectedData();
                if (dataToExport.length === 0) { alert("Nenhum dado no intervalo selecionado."); return; }
                const doc = new jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' });
                const pageWidth = doc.internal.pageSize.getWidth(); const pageHeight = doc.internal.pageSize.getHeight(); const margin = 10;
                const pId = allElements.participantIdInput.value || 'Desconhecido'; const cond = allElements.conditionSelect?.value || 'Coleta';
                const avgHrVal = allElements.avgHrValue.textContent; const peakHrVal = allElements.peakHrValue.textContent; const minHrVal = allElements.minHrValue.textContent;
                const timePerStrip = 8; const stripsPerPage = 4; // 25 mm/s padr√£o
                // Ordena por tempo e agrupa por delta de tempo ~1/SR
                const cleaned = dataToExport.filter(d => Number.isFinite(d.time) && Number.isFinite(d.signal)).sort((a, b) => a.time - b.time);
                if (cleaned.length < 2) { alert('Pouco dado para gerar PDF.'); return; }
                const totalDuration = cleaned[cleaned.length - 1].time - cleaned[0].time;
                const totalStrips = Math.ceil(totalDuration / timePerStrip);
                const stripPages = Math.ceil(totalStrips / stripsPerPage);
                // Escala: 10 mm/mV (1 mV = 1000 ¬µV)
                const uvPerMm = 100; // 100 ¬µV por mm => 10 mm/mV

                // Aplica o mesmo filtro selecionado na revis√£o (se houver)
                const reviewSelected = document.querySelector('input[name="reviewFilterType"]:checked')?.value || 'none';
                const reviewProc = new SignalProcessor(SAMPLE_RATE_HZ);
                const lpfValPdf = parseFloat(document.getElementById('review-lpf-cutoff')?.value);
                const hpfValPdf = parseFloat(document.getElementById('review-hpf-cutoff')?.value);
                if (!isNaN(lpfValPdf)) reviewProc.setLpfCutoff(lpfValPdf);
                if (!isNaN(hpfValPdf)) reviewProc.setHpfCutoff(hpfValPdf);

                // √çndice de marcadores (p√°gina(s) antes das tiras)
                const markersSorted = (recordedMarkers || []).slice().sort((a, b) => a.time - b.time);
                const rowsPerIndexPage = 40;
                const indexPages = markersSorted.length > 0 ? Math.ceil(markersSorted.length / rowsPerIndexPage) : 0;

                // P√°gina de FC (1 p√°gina se houver dados de FC)
                const hrData = extractHrTrendData();
                const hasHrPage = hrData.length > 1;

                const totalPagesCombined = indexPages + (hasHrPage ? 1 : 0) + stripPages;
                let pageCounter = 1;

                if (indexPages > 0) {
                    let idx = 0;
                    for (let ip = 0; ip < indexPages; ip++) {
                        if (ip > 0) doc.addPage();
                        doc.setFontSize(12); doc.text('√çndice de Marcadores', pageWidth / 2, margin, { align: 'center' });
                        doc.setFontSize(8);
                        doc.text(`ID do Participante: ${pId} | Condi√ß√£o: ${cond}`, margin, margin + 10);
                        doc.text(`P√°gina ${pageCounter} de ${totalPagesCombined}`, pageWidth - margin, pageHeight - 5, { align: 'right' });
                        let y = margin + 20;
                        doc.setFontSize(8); doc.setTextColor(60);
                        for (let r = 0; r < rowsPerIndexPage && idx < markersSorted.length; r++, idx++) {
                            const m = markersSorted[idx];
                            const t = `${m.time.toFixed(2)} s`;
                            const label = (m.label || 'Marcador').slice(0, 90);
                            doc.text(t, margin, y);
                            doc.text(label, margin + 25, y);
                            y += 4;
                        }
                        doc.setTextColor(0);
                        pageCounter++;
                    }
                }

                // P√°gina de Tend√™ncia de FC
                if (hasHrPage) {
                    if (pageCounter > 1) doc.addPage();

                    // T√≠tulo elegante
                    doc.setFontSize(14);
                    doc.setFont('helvetica', 'bold');
                    doc.text('Tend√™ncia de Frequ√™ncia Card√≠aca', pageWidth / 2, margin + 5, { align: 'center' });
                    doc.setFont('helvetica', 'normal');

                    // Informa√ß√µes do paciente em formato elegante
                    doc.setFontSize(9);
                    doc.setTextColor(80);
                    doc.text(`Participante: ${pId}`, margin + 20, margin + 18);
                    doc.text(`Condi√ß√£o: ${cond}`, margin + 20, margin + 24);
                    doc.text(`Data: ${new Date().toLocaleString()}`, pageWidth - margin - 20, margin + 18, { align: 'right' });

                    // M√©tricas em caixas elegantes
                    const metricsY = margin + 35;
                    const boxW = 45;
                    const boxH = 18;
                    const boxGap = 10;
                    const metricsX = (pageWidth - (3 * boxW + 2 * boxGap)) / 2;

                    // Box FC M√©dia
                    doc.setFillColor(240, 248, 255);
                    doc.setDrawColor(100, 149, 237);
                    doc.roundedRect(metricsX, metricsY, boxW, boxH, 2, 2, 'FD');
                    doc.setFontSize(7); doc.setTextColor(100);
                    doc.text('FC M√âDIA', metricsX + boxW / 2, metricsY + 5, { align: 'center' });
                    doc.setFontSize(12); doc.setTextColor(30, 64, 175);
                    doc.text(`${avgHrVal} bpm`, metricsX + boxW / 2, metricsY + 13, { align: 'center' });

                    // Box FC Pico
                    doc.setFillColor(255, 245, 245);
                    doc.setDrawColor(220, 53, 69);
                    doc.roundedRect(metricsX + boxW + boxGap, metricsY, boxW, boxH, 2, 2, 'FD');
                    doc.setFontSize(7); doc.setTextColor(100);
                    doc.text('FC PICO', metricsX + boxW + boxGap + boxW / 2, metricsY + 5, { align: 'center' });
                    doc.setFontSize(12); doc.setTextColor(220, 53, 69);
                    doc.text(`${peakHrVal} bpm`, metricsX + boxW + boxGap + boxW / 2, metricsY + 13, { align: 'center' });

                    // Box FC M√≠n
                    doc.setFillColor(245, 255, 245);
                    doc.setDrawColor(34, 139, 34);
                    doc.roundedRect(metricsX + 2 * (boxW + boxGap), metricsY, boxW, boxH, 2, 2, 'FD');
                    doc.setFontSize(7); doc.setTextColor(100);
                    doc.text('FC M√çN', metricsX + 2 * (boxW + boxGap) + boxW / 2, metricsY + 5, { align: 'center' });
                    doc.setFontSize(12); doc.setTextColor(34, 139, 34);
                    doc.text(`${minHrVal} bpm`, metricsX + 2 * (boxW + boxGap) + boxW / 2, metricsY + 13, { align: 'center' });

                    // √Årea do gr√°fico - MENOR E CENTRALIZADO
                    const chartMargin = 25;
                    const chartLeft = margin + chartMargin;
                    const chartTop = metricsY + boxH + 15;
                    const chartW = pageWidth - 2 * margin - 2 * chartMargin;
                    const chartH = 80; // Altura fixa menor

                    // Borda do gr√°fico
                    doc.setDrawColor(200); doc.setLineWidth(0.3);
                    doc.rect(chartLeft, chartTop, chartW, chartH);

                    // Grid sutil
                    doc.setDrawColor(235, 235, 235); doc.setLineWidth(0.1);
                    for (let gy = 1; gy < 5; gy++) {
                        const yLine = chartTop + (gy / 5) * chartH;
                        doc.line(chartLeft, yLine, chartLeft + chartW, yLine);
                    }
                    for (let gx = 1; gx < 10; gx++) {
                        const xLine = chartLeft + (gx / 10) * chartW;
                        doc.line(xLine, chartTop, xLine, chartTop + chartH);
                    }

                    // Escalas
                    const hrValues = hrData.map(d => d.hr);
                    const hrMin = Math.min(...hrValues);
                    const hrMax = Math.max(...hrValues);
                    const hrRange = Math.max(hrMax - hrMin, 10);
                    const hrPadding = hrRange * 0.15;
                    const hrYMin = hrMin - hrPadding;
                    const hrYMax = hrMax + hrPadding;

                    const timeMin = hrData[0].time;
                    const timeMax = hrData[hrData.length - 1].time;
                    const timeRange = timeMax - timeMin;

                    // Labels de eixo Y
                    doc.setFontSize(7); doc.setTextColor(100);
                    for (let i = 0; i <= 4; i++) {
                        const hrVal = hrYMin + (hrYMax - hrYMin) * (4 - i) / 4;
                        const yPos = chartTop + (i / 4) * chartH;
                        doc.text(`${Math.round(hrVal)}`, chartLeft - 3, yPos + 2, { align: 'right' });
                    }
                    doc.setFontSize(6);
                    doc.text('bpm', chartLeft - 3, chartTop - 3, { align: 'right' });

                    // Labels de eixo X
                    const timeLabels = 6;
                    for (let i = 0; i <= timeLabels; i++) {
                        const timeVal = timeMin + (timeRange * i / timeLabels);
                        const xPos = chartLeft + (i / timeLabels) * chartW;
                        const minutes = Math.floor(timeVal / 60);
                        const seconds = Math.floor(timeVal % 60);
                        doc.setFontSize(7);
                        doc.text(`${minutes}:${seconds.toString().padStart(2, '0')}`, xPos, chartTop + chartH + 5, { align: 'center' });
                    }

                    // Desenhar √°rea preenchida e linha de FC
                    // Preparar pontos do path
                    let pathPoints = [];
                    for (let i = 0; i < hrData.length; i++) {
                        const p = hrData[i];
                        const x = chartLeft + ((p.time - timeMin) / timeRange) * chartW;
                        const y = chartTop + ((hrYMax - p.hr) / (hrYMax - hrYMin)) * chartH;
                        pathPoints.push({ x, y, time: p.time, origTime: hrData[i].time });
                    }

                    // Desenhar √°rea preenchida com gradiente simulado (v√°rias linhas verticais)
                    // Cor vermelha clara com gradiente de cima para baixo
                    const baseY = chartTop + chartH; // Base do gr√°fico

                    // Agrupa pontos cont√≠nuos (sem gaps) e desenha pol√≠gonos
                    let segments = [];
                    let currentSegment = [];
                    for (let i = 0; i < pathPoints.length; i++) {
                        if (currentSegment.length === 0) {
                            currentSegment.push(pathPoints[i]);
                        } else if (i > 0 && hrData[i].time - hrData[i - 1].time < 10) {
                            currentSegment.push(pathPoints[i]);
                        } else {
                            if (currentSegment.length > 1) segments.push(currentSegment);
                            currentSegment = [pathPoints[i]];
                        }
                    }
                    if (currentSegment.length > 1) segments.push(currentSegment);

                    // Desenhar cada segmento como √°rea preenchida
                    segments.forEach(seg => {
                        // Criar gradiente simulado com linhas verticais
                        for (let i = 0; i < seg.length - 1; i++) {
                            const p1 = seg[i], p2 = seg[i + 1];
                            const midX = (p1.x + p2.x) / 2;
                            const maxY = Math.max(p1.y, p2.y);
                            const areaHeight = baseY - maxY;

                            // Desenhar faixas verticais com opacidade decrescente
                            const numStripes = 5;
                            for (let s = 0; s < numStripes; s++) {
                                const alpha = 0.3 - (s / numStripes) * 0.25; // Opacidade vai de 0.3 a 0.05
                                const stripeTop = maxY + (s / numStripes) * areaHeight;
                                const stripeBottom = maxY + ((s + 1) / numStripes) * areaHeight;
                                // RGB: vermelho rosado
                                const r = Math.floor(255 - s * 5);
                                const g = Math.floor(200 + s * 10);
                                const b = Math.floor(200 + s * 10);
                                doc.setFillColor(r, g, b);
                                doc.rect(p1.x, stripeTop, p2.x - p1.x, stripeBottom - stripeTop, 'F');
                            }
                        }
                    });

                    // Linha principal de FC (sobre o preenchimento)
                    doc.setDrawColor(220, 53, 69); doc.setLineWidth(0.8);
                    for (let i = 1; i < pathPoints.length; i++) {
                        const p1 = pathPoints[i - 1], p2 = pathPoints[i];
                        // Evita gaps grandes (mais de 10 segundos)
                        if (hrData[i].time - hrData[i - 1].time < 10) {
                            doc.line(p1.x, p1.y, p2.x, p2.y);
                        }
                    }

                    // Marcadores discretos
                    if (markersSorted.length > 0) {
                        doc.setDrawColor(100, 100, 255); doc.setLineWidth(0.2);
                        doc.setFontSize(5); doc.setTextColor(100, 100, 255);
                        let labelOffset = 0;
                        markersSorted.forEach((m, idx) => {
                            if (m.time >= timeMin && m.time <= timeMax) {
                                const mx = chartLeft + ((m.time - timeMin) / timeRange) * chartW;
                                doc.setLineDashPattern([1, 1], 0);
                                doc.line(mx, chartTop, mx, chartTop + chartH);
                                doc.setLineDashPattern([], 0);
                                const txt = (m.label || 'M').slice(0, 8);
                                labelOffset = (labelOffset + 4) % 12;
                                doc.text(txt, mx + 1, chartTop + 4 + labelOffset);
                            }
                        });
                    }

                    // Legenda
                    doc.setFontSize(7); doc.setTextColor(100);
                    doc.text('Tempo (min:seg)', pageWidth / 2, chartTop + chartH + 12, { align: 'center' });

                    // N√∫mero da p√°gina
                    doc.setTextColor(0);
                    doc.text(`P√°gina ${pageCounter} de ${totalPagesCombined}`, pageWidth - margin, pageHeight - 5, { align: 'right' });

                    pageCounter++;
                }
                for (let p = 0; p < stripPages; p++) {
                    if (pageCounter > 1 || p > 0) doc.addPage();
                    doc.setFontSize(12); doc.text('Relat√≥rio de Eletrocardiograma', pageWidth / 2, margin, { align: 'center' });
                    doc.setFontSize(8);
                    doc.text(`ID do Participante: ${pId} | Condi√ß√£o: ${cond}`, margin, margin + 10);
                    doc.text(`Data: ${new Date().toLocaleString()} | FC M√©dia: ${avgHrVal}bpm | FC Pico: ${peakHrVal}bpm | FC M√≠n: ${minHrVal}bpm`, margin, margin + 15);
                    doc.text(`P√°gina ${pageCounter} de ${totalPagesCombined}`, pageWidth - margin, pageHeight - 5, { align: 'right' });
                    for (let s = 0; s < stripsPerPage; s++) {
                        const stripIndex = (p * stripsPerPage) + s;
                        if (stripIndex >= totalStrips) break;
                        const stripY = margin + 20 + (s * 45); const chartWidth = pageWidth - 2 * margin; const chartHeight = 40;
                        doc.setDrawColor(230, 230, 230); doc.setLineWidth(0.1);
                        for (let x = margin; x <= margin + chartWidth; x += 1) { doc.line(x, stripY, x, stripY + chartHeight); }
                        for (let y = stripY; y <= stripY + chartHeight; y += 1) { doc.line(margin, y, margin + chartWidth, y); }
                        doc.setDrawColor(255, 204, 204); doc.setLineWidth(0.2);
                        for (let x = margin; x <= margin + chartWidth; x += 5) { doc.line(x, stripY, x, stripY + chartHeight); }
                        for (let y = stripY; y <= stripY + chartHeight; y += 5) { doc.line(margin, y, margin + chartWidth, y); }
                        doc.setDrawColor(0, 0, 255); doc.setLineWidth(0.3);
                        const stripStartTime = cleaned[0].time + stripIndex * timePerStrip;
                        const stripEndTime = stripStartTime + timePerStrip;
                        // Segmento
                        const segmentData = cleaned.filter(d => d.time >= stripStartTime && d.time < stripEndTime);
                        if (segmentData.length < 2) continue;
                        const timeScale = chartWidth / timePerStrip;
                        const mmPerUv = 1 / uvPerMm; // mm por microvolt
                        const centerY = stripY + (chartHeight / 2);
                        // Desenho seguro ponto-a-ponto em sequ√™ncia temporal (com filtro da revis√£o)
                        doc.setLineWidth(0.3);
                        // Timestamps laterais da fita
                        doc.setTextColor(80);
                        doc.text(`${stripStartTime.toFixed(2)} s`, margin, stripY - 2);
                        doc.text(`${stripEndTime.toFixed(2)} s`, margin + chartWidth, stripY - 2, { align: 'right' });
                        doc.setTextColor(0);
                        // Renderizar pequenas etiquetas de marcadores no topo da fita
                        if (recordedMarkers && recordedMarkers.length > 0) {
                            doc.setFontSize(7);
                            recordedMarkers.forEach(m => {
                                if (m.time >= stripStartTime && m.time <= stripEndTime) {
                                    const mx = margin + ((m.time - stripStartTime) / timePerStrip) * chartWidth;
                                    if (mx >= margin && mx <= margin + chartWidth) {
                                        doc.setDrawColor(255, 0, 0);
                                        doc.line(mx, stripY, mx, stripY - 2); // pequena haste
                                        const txt = (m.label || 'Marcador');
                                        doc.text(txt.length > 18 ? txt.slice(0, 18) + '‚Ä¶' : txt, mx + 1, stripY - 3);
                                    }
                                }
                            });
                            doc.setFontSize(8);
                        }
                        for (let i = 1; i < segmentData.length; i++) {
                            const p1 = segmentData[i - 1], p2 = segmentData[i];
                            const s1 = reviewProc.process(p1.signal, reviewSelected);
                            const s2 = reviewProc.process(p2.signal, reviewSelected);
                            const x1 = margin + (p1.time - stripStartTime) * timeScale;
                            const y1 = centerY - (s1 * mmPerUv);
                            const x2 = margin + (p2.time - stripStartTime) * timeScale;
                            const y2 = centerY - (s2 * mmPerUv);
                            // Evita conectar sobre quedas de pacote ou saltos an√¥malos
                            const dt = p2.time - p1.time;
                            const dAmp = Math.abs(s2 - s1);
                            const expectedDt = 1 / SAMPLE_RATE_HZ; // ~7.7ms para 130Hz
                            // Gap: delta tempo > 3x esperado (~23ms) 
                            // Comprimido: delta X muito pequeno (pontos ficariam sobrepostos)
                            const dx = x2 - x1;
                            if (dt > expectedDt * 3 || dt < expectedDt * 0.1 || dAmp > 2000 || dx < 0.1) continue;
                            // Evita estourar o limite direito
                            if (x2 <= margin + chartWidth) doc.line(x1, y1, x2, y2);
                        }
                    }
                    // Notas de rodap√©: marcadores desta p√°gina
                    const pageStartTime = cleaned[0].time + p * stripsPerPage * timePerStrip;
                    const pageEndTime = pageStartTime + stripsPerPage * timePerStrip;
                    const pageMarkers = (recordedMarkers || []).filter(m => m.time >= pageStartTime && m.time <= pageEndTime);
                    if (pageMarkers.length > 0) {
                        const startYNotes = pageHeight - 16; // acima do n√∫mero da p√°gina
                        const rowH = 3; const maxRowsPerCol = 8; const cols = 2;
                        const colW = (pageWidth - 2 * margin) / cols;
                        doc.setFontSize(7); doc.setTextColor(60);
                        doc.text('Marcadores nesta p√°gina:', margin, startYNotes - (maxRowsPerCol + 1) * rowH);
                        let r = 0; let c = 0; let y = startYNotes - maxRowsPerCol * rowH;
                        pageMarkers.forEach((m, idx) => {
                            const txt = `${m.time.toFixed(2)}s: ${(m.label || 'Marcador').slice(0, 38)}`;
                            const x = margin + c * colW;
                            doc.text(txt, x, y + r * rowH);
                            r++;
                            if (r >= maxRowsPerCol) { r = 0; c++; }
                            if (c >= cols) return; // corta se exceder espa√ßo
                        });
                        doc.setTextColor(0);
                    }
                    pageCounter++;
                }
                doc.save(`${getFileName()}.pdf`);
            });

            function updateFilterInputs() {
                const selected = document.querySelector('input[name="filterType"]:checked').value;
                let html = '';
                if (selected === 'lpf') { html = `<label class="text-sm">F.Corte(Hz): <input type="number" id="lpf-cutoff" class="w-20 border-gray-300 rounded-md shadow-sm" value="40"></label>`; }
                else if (selected === 'hpf') { html = `<label class="text-sm">F.Corte(Hz): <input type="number" id="hpf-cutoff" class="w-20 border-gray-300 rounded-md shadow-sm" value="0.5"></label>`; }
                else if (selected === 'bandpass') { html = `<label class="text-sm">Inf(Hz): <input type="number" id="hpf-cutoff" class="w-20 border-gray-300 rounded-md shadow-sm" value="0.5"></label><label class="text-sm">Sup(Hz): <input type="number" id="lpf-cutoff" class="w-20 border-gray-300 rounded-md shadow-sm" value="40"></label>`; }
                const paramsSpan = document.getElementById('filter-params');
                if (paramsSpan) paramsSpan.innerHTML = html;
                attachFilterInputListeners();
                updateLiveFilterToggleBinding();
            }

            function attachFilterInputListeners() {
                const hpfInput = document.getElementById('hpf-cutoff');
                const lpfInput = document.getElementById('lpf-cutoff');
                if (hpfInput) { hpfInput.addEventListener('change', (e) => { const val = parseFloat(e.target.value); if (signalProcessor && !isNaN(val)) signalProcessor.setHpfCutoff(val); }); }
                if (lpfInput) { lpfInput.addEventListener('change', (e) => { const val = parseFloat(e.target.value); if (signalProcessor && !isNaN(val)) signalProcessor.setLpfCutoff(val); }); }
            }

            document.querySelectorAll('input[name="filterType"]').forEach(radio => { radio.addEventListener('change', updateFilterInputs); });
            function updateLiveFilterToggleBinding() {
                const liveFilterToggle = document.getElementById('liveFilterToggle');
                if (liveFilterToggle) {
                    liveFilterToggle.checked = enableLiveFilter;
                    liveFilterToggle.onchange = (e) => { enableLiveFilter = e.target.checked; updateChartWithLiveData(); };
                }
            }
            updateLiveFilterToggleBinding();

            allElements.timeZoomIn.addEventListener('click', () => { if (currentTimeZoomIndex > 0) { currentTimeZoomIndex--; MAX_DATA_POINTS = timeConfigs[currentTimeZoomIndex].points; allElements.timeZoomLabel.textContent = timeConfigs[currentTimeZoomIndex].label; } });
            allElements.timeZoomOut.addEventListener('click', () => { if (currentTimeZoomIndex < timeConfigs.length - 1) { currentTimeZoomIndex++; MAX_DATA_POINTS = timeConfigs[currentTimeZoomIndex].points; allElements.timeZoomLabel.textContent = timeConfigs[currentTimeZoomIndex].label; } });
            allElements.voltageZoomIn.addEventListener('click', () => { if (currentVoltageZoomIndex > 0) { currentVoltageZoomIndex--; const config = voltageConfigs[currentVoltageZoomIndex]; allElements.voltageZoomLabel.textContent = config.label; ecgChart.options.scales.y.min = config.min; ecgChart.options.scales.y.max = config.max; ecgChart.update(); } });
            allElements.voltageZoomOut.addEventListener('click', () => { if (currentVoltageZoomIndex < voltageConfigs.length - 1) { currentVoltageZoomIndex++; const config = voltageConfigs[currentVoltageZoomIndex]; allElements.voltageZoomLabel.textContent = config.label; ecgChart.options.scales.y.min = config.min; ecgChart.options.scales.y.max = config.max; ecgChart.update(); } });

            initChart();
            updateFilterInputs();

            // Verificar se h√° sess√£o auto-salva
            (async function checkAutoSave() {
                try {
                    const db = await openDB();
                    const tx = db.transaction('sessions', 'readonly');
                    const req = tx.objectStore('sessions').get('__autosave__');
                    req.onsuccess = () => {
                        const sess = req.result;
                        if (sess && sess.data && sess.data.length > 0) {
                            const createdAt = sess.createdAt ? new Date(sess.createdAt).toLocaleString() : 'desconhecido';
                            const duration = sess.data.length > 0 ? (sess.data[sess.data.length - 1].time / 60).toFixed(1) : 0;
                            if (confirm(`üîÑ Sess√£o n√£o salva encontrada!\n\nData: ${createdAt}\nDura√ß√£o: ~${duration} min\nPontos: ${sess.data.length}\n\nDeseja recuperar esta sess√£o?`)) {
                                recordedData = sess.data || [];
                                recordedMarkers = sess.markers || [];
                                allElements.participantIdInput.value = sess.participant || '';
                                // Campo condi√ß√£o foi removido
                                hasUnsavedData = true;
                                displayReview();
                                alert('Sess√£o recuperada! Por favor, exporte para arquivo assim que poss√≠vel.');
                            } else {
                                // Limpar auto-save se usu√°rio n√£o quiser recuperar
                                const delTx = db.transaction('sessions', 'readwrite');
                                delTx.objectStore('sessions').delete('__autosave__');
                            }
                        }
                    };
                } catch (err) {
                    console.warn('Falha ao verificar auto-save:', err);
                }
            })();
            // Registrar service worker
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('service-worker.js').catch(() => { });
                });
            }
            // Toggle da sobreposi√ß√£o
            if (allElements.hrOverlayToggle) {
                allElements.hrOverlayToggle.addEventListener('change', (e) => {
                    const show = e.target.checked;
                    if (show) {
                        allElements.hrOverlay.classList.remove('hidden');
                        // Opcional: esconder chip original de HR
                        allElements.hrDisplay.classList.add('hidden');
                        // Preenche valores atuais
                        allElements.hrOverlayCurrent.textContent = lastHr ?? '--';
                        allElements.hrOverlayMin.textContent = (minHr === 300) ? '--' : minHr;
                        allElements.hrOverlayPeak.textContent = (peakHr === 0) ? '--' : peakHr;
                        allElements.hrOverlayAvg.textContent = (avgHr > 0) ? Math.round(avgHr) : '--';
                    } else {
                        allElements.hrOverlay.classList.add('hidden');
                        allElements.hrDisplay.classList.remove('hidden');
                    }
                });
            }
            // Listeners para filtros de revis√£o
            document.querySelectorAll('input[name="reviewFilterType"]').forEach(radio => {
                radio.addEventListener('change', () => { updateReviewFilterInputs(); updateReviewChartData(); });
            });
            // Clique no gr√°fico para inserir marcador durante a grava√ß√£o
            allElements.liveChartCtx.canvas.addEventListener('click', (evt) => {
                if (!isRecording) return;
                const xScale = ecgChart.scales.x;
                if (!xScale) return;
                const rect = evt.target.getBoundingClientRect();
                const x = evt.clientX - rect.left;
                const timeAtClick = xScale.getValueForPixel(x);
                if (timeAtClick == null || isNaN(timeAtClick)) return;
                const label = allElements.markerInput.value || 'Marcador';
                recordedMarkers.push({ time: parseFloat(Number(timeAtClick).toFixed(2)), label });
                allElements.markerInput.value = '';
                updateLiveMarkersDataset();
            });
        });
    </script>
</body>

</html>